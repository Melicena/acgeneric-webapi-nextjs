import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { UsuarioMapper, AsociacionMapper, type UsuarioModel } from '@/lib/types'

/**
 * GET /api/usuarios/[id]
 * Obtiene un usuario por ID con sus asociaciones administradas
 */
export async function GET(
    request: NextRequest,
    { params }: { params: { id: string } }
) {
    try {
        const supabase = createClient()
        const userId = params.id

        // 1. Obtener el usuario
        const { data: usuario, error: userError } = await supabase
            .from('usuarios')
            .select('*')
            .eq('id', userId)
            .single()

        if (userError) {
            return NextResponse.json(
                { error: 'Usuario no encontrado', details: userError.message },
                { status: 404 }
            )
        }

        if (!usuario) {
            return NextResponse.json(
                { error: 'Usuario no encontrado' },
                { status: 404 }
            )
        }

        // 2. Obtener las asociaciones que administra (si tiene)
        const { data: associations, error: assocError } = await supabase
            .from('associations')
            .select('*')
            .eq('admin_user_id', userId)
            .order('created_at', { ascending: false })

        if (assocError) {
            console.error('Error al obtener asociaciones:', assocError)
            // No fallar si hay error en asociaciones, solo continuar sin ellas
        }

        // 3. Mapear a los modelos de dominio
        const managedAssociations = associations?.map(AsociacionMapper.toDomain) || []
        const userModel: UsuarioModel = UsuarioMapper.toDomain(usuario, managedAssociations)

        // 4. Retornar el usuario con sus asociaciones
        return NextResponse.json({
            success: true,
            data: userModel,
            meta: {
                isAssociationAdmin: userModel.managedAssociations !== null && userModel.managedAssociations.length > 0,
                totalManagedAssociations: userModel.managedAssociations?.length || 0
            }
        })

    } catch (error) {
        console.error('Error en GET /api/usuarios/[id]:', error)
        return NextResponse.json(
            { error: 'Error interno del servidor' },
            { status: 500 }
        )
    }
}

/**
 * PATCH /api/usuarios/[id]
 * Actualiza un usuario
 */
export async function PATCH(
    request: NextRequest,
    { params }: { params: { id: string } }
) {
    try {
        const supabase = createClient()
        const userId = params.id
        const body = await request.json()

        // Validar que el usuario autenticado sea el mismo que se intenta actualizar
        const { data: { user } } = await supabase.auth.getUser()
        
        if (!user || user.id !== userId) {
            return NextResponse.json(
                { error: 'No autorizado' },
                { status: 403 }
            )
        }

        // Actualizar el usuario
        const { data: updatedUser, error } = await supabase
            .from('usuarios')
            .update({
                display_name: body.displayName,
                avatar_url: body.avatarUrl,
                comercios: body.comercios,
                comercios_subs: body.comerciosSubs,
                ultimo_acceso: new Date().toISOString()
            })
            .eq('id', userId)
            .select()
            .single()

        if (error) {
            return NextResponse.json(
                { error: 'Error al actualizar usuario', details: error.message },
                { status: 400 }
            )
        }

        // Obtener asociaciones actualizadas
        const { data: associations } = await supabase
            .from('associations')
            .select('*')
            .eq('admin_user_id', userId)

        const managedAssociations = associations?.map(AsociacionMapper.toDomain) || []
        const userModel = UsuarioMapper.toDomain(updatedUser, managedAssociations)

        return NextResponse.json({
            success: true,
            data: userModel
        })

    } catch (error) {
        console.error('Error en PATCH /api/usuarios/[id]:', error)
        return NextResponse.json(
            { error: 'Error interno del servidor' },
            { status: 500 }
        )
    }
}

/**
 * DELETE /api/usuarios/[id]
 * Elimina un usuario (y sus asociaciones en cascada)
 */
export async function DELETE(
    request: NextRequest,
    { params }: { params: { id: string } }
) {
    try {
        const supabase = createClient()
        const userId = params.id

        // Validar que el usuario autenticado sea el mismo que se intenta eliminar
        const { data: { user } } = await supabase.auth.getUser()
        
        if (!user || user.id !== userId) {
            return NextResponse.json(
                { error: 'No autorizado' },
                { status: 403 }
            )
        }

        // Eliminar el usuario (las asociaciones se eliminan en cascada)
        const { error } = await supabase
            .from('usuarios')
            .delete()
            .eq('id', userId)

        if (error) {
            return NextResponse.json(
                { error: 'Error al eliminar usuario', details: error.message },
                { status: 400 }
            )
        }

        return NextResponse.json({
            success: true,
            message: 'Usuario eliminado correctamente'
        })

    } catch (error) {
        console.error('Error en DELETE /api/usuarios/[id]:', error)
        return NextResponse.json(
            { error: 'Error interno del servidor' },
            { status: 500 }
        )
    }
}
