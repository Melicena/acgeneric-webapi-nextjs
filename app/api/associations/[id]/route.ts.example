import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { AsociacionMapper } from '@/lib/types'

/**
 * GET /api/associations/[id]
 * Obtiene una asociación por ID
 */
export async function GET(
    request: NextRequest,
    { params }: { params: { id: string } }
) {
    try {
        const supabase = createClient()
        const associationId = params.id

        const { data: association, error } = await supabase
            .from('associations')
            .select('*')
            .eq('id', associationId)
            .single()

        if (error || !association) {
            return NextResponse.json(
                { error: 'Asociación no encontrada' },
                { status: 404 }
            )
        }

        const associationModel = AsociacionMapper.toDomain(association)

        return NextResponse.json({
            success: true,
            data: associationModel
        })

    } catch (error) {
        console.error('Error en GET /api/associations/[id]:', error)
        return NextResponse.json(
            { error: 'Error interno del servidor' },
            { status: 500 }
        )
    }
}

/**
 * PATCH /api/associations/[id]
 * Actualiza una asociación
 * Body puede incluir:
 * {
 *   nombre?: string
 *   descripcion?: string
 *   logoUrl?: string
 *   comerciosIds?: string[]
 *   activa?: boolean
 * }
 */
export async function PATCH(
    request: NextRequest,
    { params }: { params: { id: string } }
) {
    try {
        const supabase = createClient()
        const associationId = params.id
        const body = await request.json()

        // Obtener el usuario autenticado
        const { data: { user }, error: authError } = await supabase.auth.getUser()
        
        if (authError || !user) {
            return NextResponse.json(
                { error: 'No autenticado' },
                { status: 401 }
            )
        }

        // Verificar que el usuario sea el administrador de la asociación
        const { data: association, error: fetchError } = await supabase
            .from('associations')
            .select('admin_user_id')
            .eq('id', associationId)
            .single()

        if (fetchError || !association) {
            return NextResponse.json(
                { error: 'Asociación no encontrada' },
                { status: 404 }
            )
        }

        if (association.admin_user_id !== user.id) {
            return NextResponse.json(
                { error: 'No autorizado. Solo el administrador puede modificar la asociación' },
                { status: 403 }
            )
        }

        // Preparar datos de actualización
        const updateData: any = {}
        
        if (body.nombre !== undefined) updateData.nombre = body.nombre
        if (body.descripcion !== undefined) updateData.descripcion = body.descripcion
        if (body.logoUrl !== undefined) updateData.logo_url = body.logoUrl
        if (body.comerciosIds !== undefined) updateData.comercios_ids = body.comerciosIds
        if (body.activa !== undefined) updateData.activa = body.activa

        // Actualizar la asociación
        const { data: updatedAssociation, error: updateError } = await supabase
            .from('associations')
            .update(updateData)
            .eq('id', associationId)
            .select()
            .single()

        if (updateError) {
            return NextResponse.json(
                { error: 'Error al actualizar asociación', details: updateError.message },
                { status: 400 }
            )
        }

        const associationModel = AsociacionMapper.toDomain(updatedAssociation)

        return NextResponse.json({
            success: true,
            data: associationModel,
            message: 'Asociación actualizada correctamente'
        })

    } catch (error) {
        console.error('Error en PATCH /api/associations/[id]:', error)
        return NextResponse.json(
            { error: 'Error interno del servidor' },
            { status: 500 }
        )
    }
}

/**
 * DELETE /api/associations/[id]
 * Elimina una asociación
 */
export async function DELETE(
    request: NextRequest,
    { params }: { params: { id: string } }
) {
    try {
        const supabase = createClient()
        const associationId = params.id

        // Obtener el usuario autenticado
        const { data: { user }, error: authError } = await supabase.auth.getUser()
        
        if (authError || !user) {
            return NextResponse.json(
                { error: 'No autenticado' },
                { status: 401 }
            )
        }

        // Verificar que el usuario sea el administrador
        const { data: association, error: fetchError } = await supabase
            .from('associations')
            .select('admin_user_id')
            .eq('id', associationId)
            .single()

        if (fetchError || !association) {
            return NextResponse.json(
                { error: 'Asociación no encontrada' },
                { status: 404 }
            )
        }

        if (association.admin_user_id !== user.id) {
            return NextResponse.json(
                { error: 'No autorizado. Solo el administrador puede eliminar la asociación' },
                { status: 403 }
            )
        }

        // Eliminar la asociación
        const { error: deleteError } = await supabase
            .from('associations')
            .delete()
            .eq('id', associationId)

        if (deleteError) {
            return NextResponse.json(
                { error: 'Error al eliminar asociación', details: deleteError.message },
                { status: 400 }
            )
        }

        return NextResponse.json({
            success: true,
            message: 'Asociación eliminada correctamente'
        })

    } catch (error) {
        console.error('Error en DELETE /api/associations/[id]:', error)
        return NextResponse.json(
            { error: 'Error interno del servidor' },
            { status: 500 }
        )
    }
}

/**
 * POST /api/associations/[id]/comercios
 * Agrega un comercio a la asociación
 * Body:
 * {
 *   comercioId: string
 * }
 */
export async function POST(
    request: NextRequest,
    { params }: { params: { id: string } }
) {
    try {
        const supabase = createClient()
        const associationId = params.id
        const body = await request.json()

        if (!body.comercioId) {
            return NextResponse.json(
                { error: 'comercioId es requerido' },
                { status: 400 }
            )
        }

        // Obtener el usuario autenticado
        const { data: { user }, error: authError } = await supabase.auth.getUser()
        
        if (authError || !user) {
            return NextResponse.json(
                { error: 'No autenticado' },
                { status: 401 }
            )
        }

        // Obtener la asociación actual
        const { data: association, error: fetchError } = await supabase
            .from('associations')
            .select('*')
            .eq('id', associationId)
            .single()

        if (fetchError || !association) {
            return NextResponse.json(
                { error: 'Asociación no encontrada' },
                { status: 404 }
            )
        }

        if (association.admin_user_id !== user.id) {
            return NextResponse.json(
                { error: 'No autorizado' },
                { status: 403 }
            )
        }

        // Verificar si el comercio ya está en la lista
        const comerciosIds = association.comercios_ids || []
        if (comerciosIds.includes(body.comercioId)) {
            return NextResponse.json(
                { error: 'El comercio ya está en la asociación' },
                { status: 400 }
            )
        }

        // Agregar el comercio
        const updatedComerciosIds = [...comerciosIds, body.comercioId]

        const { data: updatedAssociation, error: updateError } = await supabase
            .from('associations')
            .update({ comercios_ids: updatedComerciosIds })
            .eq('id', associationId)
            .select()
            .single()

        if (updateError) {
            return NextResponse.json(
                { error: 'Error al agregar comercio', details: updateError.message },
                { status: 400 }
            )
        }

        const associationModel = AsociacionMapper.toDomain(updatedAssociation)

        return NextResponse.json({
            success: true,
            data: associationModel,
            message: 'Comercio agregado correctamente'
        })

    } catch (error) {
        console.error('Error en POST /api/associations/[id]/comercios:', error)
        return NextResponse.json(
            { error: 'Error interno del servidor' },
            { status: 500 }
        )
    }
}
